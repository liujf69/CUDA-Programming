# GPU架构
GPU架构基于流式多处理器（SM）的可扩展阵列搭建。
```
1. GPU中含有多个SM，每一个SM都支持多个线程并发执行。
2. 当启动一个内核网格时，线程块会被分配到可用的SM中执行。
3. 当线程块被调度到一个SM中时，线程块的线程只会在这个指定的SM中并发执行，多个线程块可能被分配到同一个SM中。
```
SM是GPU架构的核心，寄存器和共享内存是SM中的稀缺资源。

## 经典GPU架构
```
1. Fermi架构
    Fermi架构拥有512个加速器核心（CUDA核心）。
    每个CUDA核心拥有一个整数算术逻辑单元（ALU）和一个浮点运算单元（FPU），每个时钟周期执行一个整数或浮点数运算。
    CUDA核心被组织到16个SM中（取决于显卡型号），每一个SM含有32个CUDA核心。
    每一个SM含有两个线程束调度器和两个指令调度单元。当一个线程块被指定到一个SM时，线程块的所有线程都被划分为线程束。
2. Kepler架构
    Kepler架构的优势: 强化的SM、动态并行和Hyper-Q技术
    强化的SM: 通过结构的创新提高编程效率和功率效率。
    动态并行: 允许GPU动态地启动新的网格，任一内核都能启动其他的内核（核函数中调用其他核函数）。
    Hyper-Q技术: 提供了多个硬件工作队列，增加了CPU和GPU之间的同步硬件连接，避免由于一个单独的任务阻塞队列中的其他任务。（Fermi架构只有一个硬件工作队列）
```

## 线程束
CUDA采用单指令多线程（SIMT）架构来管理和执行线程，每32个线程为一组构成线程束。
```
SIMT模型的特点:
    1. 每个线程都有自己的指令地址计数器。
    2. 每个线程都有自己的寄存器状态。
    3. 每个线程可以有一个独立的执行路径。
```

## nvcc编译流程
nvcc先将设备代码编译为PTX（Parallel Thread Execution）伪汇编代码，再将PTX代码编译为二进制的cubin目标代码。
```
1. 编译为PTX代码时，需要用选项-arch=compute_XY指定一个虚拟架构的计算能力，以确定代码中能够使用的CUDA功能。
2. 编译为cubin代码时，需要用选项-code=compute_ZW指定一个真实架构的计算能力，以确定可执行文件能够使用的GPU。
```
nvcc编译指令使用两个体系结构：虚拟的中间体系结构（对应虚拟架构的计算能力）和实际的GPU体系结构（对应真实架构的计算能力）。
```
1. 虚拟架构应该尽可能选择版本低的（虚拟计算能力小），以适配更多实际的GPU
2. 真实架构应该尽可能选择版本高的（真实计算能力大），以充分发挥GPU的性能
```
## nvcc编译指令
1.指定虚拟架构的计算能力: -arch=compute_XY，X表示计算能力的主版本号（一般是同一个GPU架构），Y表示计算能力的次版本号（一般是同一个GPU架构的不同显卡）
```bash
nvcc test.cu -o test -arch=compute_61
# 编译出的可执行文件可以在计算能力>=6.1上的GPU执行，在计算能力<6.1的GPU则不能执行。
```
2.指定真实架构的计算能力: -code=sm_XY， X表示计算能力的主版本号，Y表示计算能力的次版本号
```bash
# 二进制cubin的代码在大版本之间不兼容（不同版本的显卡不能运行）
# 指定真实架构的计算能力必须同时指定虚拟架构的计算能力
# 指定真实的架构能力必须>=虚拟架构的能力
# 真实架构可以实现低小版本到高小版本的兼容，即计算能力更高的显卡往往能运行用计算能力低的显卡编译出来的程序。
```
3.指定多个GPU版本编译: 使用-gencode arch=compute_XY -code=sm_XY
```bash
# -gencode=arch=compute_35, code=sm_35 表示开普勒架构
# -gencode=arch=compute_50, code=sm_50 表示麦克斯韦架构
# -gencode=arch=compute_60, code=sm_60 表示帕斯卡架构
# -gencode=arch=compute_70, code=sm_70 表示伏特架构
nvcc -test.cu -o test -gencode=arch=compute_35, code=sm_35 -gencode=arch=compute_50, code=sm_50
```
4.当使用nvcc编译程序时，如果不显式指定虚拟计算能力和真实计算能力，nvcc将使用默认的虚拟计算能力和真实的计算能力进行编译，默认值取决于使用的CUDA版本。
   